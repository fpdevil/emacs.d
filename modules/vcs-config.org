#+begin_src emacs-lisp :exports none
;;; -*- lexical-binding: t -*-
;;; vcs-config.el --- Version Control System
;;
;; Author: Sampath Singamsetty
;;
;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file
;; addons-config.org
;;
;;; Commentary:
;; This module contains the packages to deal with the Version Control
;; Systems specifically with github and it's associated packages.
;;
;;; Code:
;;;
#+end_src

* Git Version Control :TOC_4:
- [[#magit---a-git-porcelain-inside-emacs][Magit - A Git Porcelain inside Emacs]]
  - [[#magit-key-bindings][Magit Key Bindings]]
  - [[#quick-guide][Quick guide]]
- [[#display-when-a-line-was-modified-and-by-whom][Display when a line was modified and by whom]]

* Magit - A Git Porcelain inside Emacs
~Magit~ is an interface to the version control system ~Git~, implemented as an Emacs
package. ~Magit~  aspires to be  a complete ~Git~  porcelain. While we  cannot (yet)
claim that  ~Magit~ wraps  and improves  upon each  and every  ~Git~ command,  it is
complete enough  to allow even  experienced ~Git~ users  to perform almost  all of
their daily  version control tasks directly  from within Emacs. While  many fine
~Git~ clients exist, only Magit and ~Git~ itself deserve to be called porcelains.

Customisation's aren't really needed, except perhaps for some keybindings:
#+begin_src emacs-lisp :lexical no
;; Magit - A Git Porcelain inside Emacs
;; At the bottom of Emacs, we can see which branch we are on
;; and whether the local file is modified or not
(use-package magit
  :straight
  (magit :type git :host github :repo "magit/magit")
  :ensure t
  :defer 3
  :commands (magit-status magit-get-current-branch)
  :init (require 'magit-files)
  :bind (("C-c g g" . magit-status)
         ("C-c g o" . magit-file-popup)
         ("C-c g p" . magit-push)
         ("C-c g d" . magit-file-dispatch)
         ("C-c g l" . magit-log-buffer-file)
         ("C-c g L" . magit-log-head)
         ("C-c g b" . magit-blame)
         :map magit-status-mode-map
         ("q"       . magit-quit-session))
  :config
  (setq magit-blame-styles
	'((headings
	   (heading-format . "%-20a %C %s\n"))
	  (highlight
	   (highlight-face . magit-blame-highlight))
	  (lines
	   (show-lines . t)
	   (show-message . t))))

  (defun magit-quit-session ()
    "Restore the previous window configuration and kill the magit buffer."
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen)))
#+end_src

** Magit Key Bindings
 + ~C-c g g~: *magit-status* :: gives you a nice buffer with an overview of the Git
   repo that you're buffer is currently visiting.
 + ~C-c g f~: *magit-file-dispatch* :: lets you invoke Git actions on the current
   file directly; e.g., following up with blame, log, diff, stage, or commit the
   current file.

** Quick guide
Here is a quick guide to working with magit which were excerpts from the blog
[[http://jr0cket.co.uk/2012/12/driving-git-with-emacs-pure-magic-with.html.html][jr0cket's blog]].

+ ~dired~ :: View the contents of a particular directory.

+ ~magit-init~ :: Put a project under the ~git~ version control.
  The mini-buffer will prompt you for the top level folder version.
  A ~.git~ folder will be created there.

+ ~magit-status~ ~C-c g g~ :: View the status in another buffer.
                          Now Press ~?~ to view all the options, including:
  A) g :: Refresh the status buffer.
      # The status buffer may be refereshed using ~g~, and all magit buffers by ~G~.
  B) TAB ::  See collapsed items, such as what text has been changed.
  C) ~q~ :: Quit magit, or go to previous magit screen.
  D) ~s~ :: Stage, i.e., add, a file to ~git~ version control.
          Add all untracked files by selecting the /Untracked files/ title.

     [[https://softwareengineering.stackexchange.com/a/119807/185815][The staging area is akin to a pet store; commiting is taking the pet home.]]

  E) ~k~ :: Kill, i.e., delete a file locally.
  F) ~K~ :: The command ~magit-file-untrack~ which does ~git rm --cached~.
  G) ~i~ :: Add a file to the project ~.gitignore~ file to exclude it from the ~git~
     version control.
  H) ~u~ :: Unstage a specific staged change highlighed by the cursor.
            ~C-u s~ stages everything -- whether tracked or not.
  I) ~c~ :: Commit a change.

     * A new buffer for the commit message appears, you write it then
       commit with ~C-c C-c~ or otherwise cancel with ~C-c C-k~.
       These commands are mentioned to you in the minibuffer when you go to
       commit.
     * You can provide a commit to /each/ altered chunk of text!
       This is super neat, you make a series of local such commits rather
       than one nebulous global commit for the file. The ~magit~ interface
       makes this far more accessible than a standard terminal approach!
     * You can look at the unstaged changes, select a /region/, using ~C-SPC~ as
       usual, and commit only that if you want!
     * When looking over a commit, ~M-p/n~ to efficiently go to previous or next
       altered sections.
     * Amend a commit by pressing ~a~ on ~HEAD~.

  J) ~d~ :: Show differences, another ~d~ or another option.
     - This is magit! Each hunk can be acted upon; e.g., ~s~ or ~c~ or ~k~ ;-)
  K) ~v~ :: Revert a commit.
  L) ~x~ :: Undo last commit. Tantamount to ~git reset HEAD~~ when cursor is on most recent
            commit; otherwise resets to whatever commit is under the cursor.
  M) ~l~ :: Show the log, another ~l~ for current branch; other options will be displayed.
     - Here ~space~ shows details in another buffer while cursour remains in current
       buffer and, moreover, continuing to press ~space~ scrolls through the other buffer!
  N) ~P~ :: Push.
  O) ~F~ :: Pull.
  P) ~:~ :: Execute a raw git command; e.g., enter ~whatchanged~.

Notice that every time we press one of these commands, a "pop-up" of realted
git options appears! Thus not only is there no need to memorise many of them,
but this approach makes /discovering/ other commands easily.

* Display when a line was modified and by whom
~blamer.el~ is an Emacs plugin that quickly & automatically provides a glimpse of
who, why, and when a line or code block was changed. It allows to jump back
through history to gain further insights as to how and why the code evolved with
~C-x g L~ (magit-log-head) or git-timemachine.

#+begin_src emacs-lisp :lexical no
;; blamer.el - A git blame plugin for emacs to display when
;; and who modified a line
(use-package blamer
  :straight
  (:host github :repo "artawower/blamer.el")
  :defer 3
  :bind (("C-c g s i" . blamer-show-commit-info))
  :custom
  (blamer-idle-time 0.3)
  (blamer-min-offset 70)
  (blamer-view 'overlay-popup)
  (blamer--overlay-popup-position 'smart)
  (blamer-max-commit-message-length 80)
  (blamer-author-formatter "  ✎ %s ")
  (blamer-datetime-formatter "[%s]")
  (blamer-commit-formatter " ● %s")
  (blamer-prettify-time-p t)
  (blamer-tooltip-function #'aqua/blamer-tooltip-func)
  :custom-face
  (blamer-face ((t :foreground "#7a88cf"
                    :background nil
                    :height 140
                    :italic t)))
  :preface
  (defun aqua/blamer-tooltip-func (commit-info)
  (let ((commit-date (plist-get commit-info :commit-date))
        (commit-time (plist-get commit-info :commit-time)))
    (message "%s" commit-info)
    (format "%s - %s" commit-date commit-time)))
  :config
  (global-blamer-mode 1))
#+end_src
