:DOC-CONFIG:
#+property: header-args :emacs-lisp :tangle (concat (file-name-sans-extension (buffer-file-name)) ".el")
#+property: header-args :mkdirp yes :comments no
:END:

#+begin_src emacs-lisp :exports none
;;; package --- documentation modes configuration -*- lexical-binding:t ; -*-
;;;
;;; Commentary
;;; DO NOT EDIT THIS FILE DIRECTLY
;;; This is a file generated from a literate programing source file
;;; ORG mode configuration
;;; Filename           : cpp-config.el
;;; Description        : C/C++ IDE Support
;;; Date               :
;;; Last Modified Date :
;;
;;
;; run the below and add into ..clang_complete
;; echo | clang -x c++ -v -E - 2>&1
;; | sed -n '/^#include </,/^End/s|^[^/]*\([^ ]*/include[^ ]*\).*$|-I\1|p'
;;
;; cpp -v
;;
;; elisp code for customizing the C/C++ development on Emacs
;; reference http://nilsdeppe.com/posts/emacs-c++-ide
;; https://github.com/google/styleguide
;;
;; a sample c++ project creation command
;; { mkdir -p hello/src; \
;;       printf "#include <stdio.h>\nint main(void) {\nprintf(\"hello world\"); \
;;       \nreturn 0;\n}" > \
;;       hello/src/main.cpp;printf "cmake_minimum_required(VERSION 2.6) \
;;       \nadd_executable(main main.cpp)" > \
;;       hello/src/CMakeLists.txt
;; }
;;
;; Compilation for OpenCV
;; g++ -std=c++17 <input_file.cpp> -o <output_file> `pkg-config --cflags --libs opencv`
;;
;; References
;; https://tuhdo.github.io/c-ide.html
;;
;;; Code:
;;;
#+end_src

#+TITLE: CPP Configuration
#+STARTUP: indent

* CPP Configuration                                                   :TOC_4:
  - [[#utility-functions][Utility functions]]
  - [[#indentation][Indentation]]
  - [[#cc-mode][cc-mode]]
  - [[#some-lsp-configuration][Some LSP configuration]]
- [[#ccls][ccls]]
- [[#irony-mode][Irony mode]]
  - [[#basic-setup][Basic setup]]
    - [[#package-installation-in-emacs][Package installation in =Emacs=]]
    - [[#the-simplest-configuration][The simplest configuration]]
  - [[#irony-server-installation-post-the-elisp-package-installation][irony-server installation post the =elisp= package installation]]
    - [[#build-instructions][Build instructions]]
      - [[#create-build-directories][Create build directories]]
      - [[#now-run-the-cmake-from-inside-the-build-directory-using-the-below-commands][Now run the =cmake= from inside the build directory, using the below command(s)]]
      - [[#check-and-configure][Check and configure]]
  - [[#company-mode-integration-using-company-irony][Company mode integration using company-irony]]
  - [[#eldoc-integration][Eldoc integration]]
  - [[#flycheck-integration][Flycheck integration]]
- [[#coding-conventions][Coding conventions]]
- [[#cmake][Cmake]]
  - [[#cmake-font-lock][Cmake font lock]]
  - [[#compiling-with-cmake-ide][Compiling with cmake-ide]]
- [[#code-formatting][Code formatting]]
  - [[#format-configuration-file][Format configuration file]]
  - [[#clang-format-plus][clang-format-plus]]
- [[#font-locking][Font locking]]
- [[#code-compilation-helpers][Code compilation helpers]]
- [[#sample-stubs][Sample stubs]]
  - [[#special-macros-to-be-used-in-makefiles][Special Macros to be used in Makefiles]]

** Utility functions
Some utility functions for general purpose

#+begin_src emacs-lisp :lexical no
(defun aqua/get-process (command &rest args)
  "Execute COMMAND with ARGS synchronously.

Returns (STATUS . OUTPUT) when it is done, where STATUS is the returned error
code of the process and OUTPUT is its stdout output."
  (with-temp-buffer
    (cons (or (apply #'call-process command nil t nil (remq nil args))
              -1)
          (string-trim (buffer-string)))))

;; Utility function
(defun my/tabs-setup (tabs length)
  (setq-default indent-tabs-mode tabs)
  (setq-default tab-width length)
  (setq-default tab-stop-list (number-sequence length 100 length)))
#+end_src

** Indentation
Set proper indentation for the code while typing.

The [[http://blog.binchen.org/posts/ccjava-code-indentation-in-emacs.html][link]] has been used as a reference.

#+begin_src emacs-lisp :lexical no
(defun fix-c-indent-offset-according-to-syntax-context (key val)
  ;; remove the old element
  (setq c-offsets-alist (delq (assoc key c-offsets-alist) c-offsets-alist))
  ;; new value
  (add-to-list 'c-offsets-alist '(key . val)))

(add-hook 'c-mode-common-hook
          (lambda ()
            (when (derived-mode-p 'c-mode 'c++-mode)
              ;; indentation
              (fix-c-indent-offset-according-to-syntax-context 'substatement 0)
              (fix-c-indent-offset-according-to-syntax-context 'func-decl-cont 0))))
#+end_src

 When ENTER is pressed, the new line will be inserted, then the function
 ~indent-according-to-mode~ will always be called ~indent-according-to-mode~ will
 call function object ~indent-line-function~ if it's not ~nil~.
 In =C/C++/Java=, that object is actually =c-indent-line= unless updated.

Additional formatting settings

#+begin_src emacs-lisp :tangle no
(defun aqua/cpp-mode-hook ()
  ;; EMACS customizations for c++-mode
  (c-set-offset 'substatement-open 0)
  (c-set-offset 'innamespace 0)

  ;; other customizations can go here
  (setq c-tab-always-indent t)
  (setq c-basic-offset 4)                  ;; Default is 2
  (setq c-indent-level 4)                  ;; Default is 2
  (setq c-indent-level 4)
  (setq c-empty-arglist-indent 4)
  (setq c-continued-statement-offset 4)

  (setq c-auto-hungry-initial-state 'none)
  (setq c-delete-function 'backward-delete-char)

  (setq c-default-style "linux")
  (setq c-file-style "linux")
  (setq tab-stop-list '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60))
  (setq tab-width 4)
  (setq indent-tabs-mode nil)  ; use tabs if t
  )

(add-hook 'c++-mode-hook 'aqua/cpp-mode-hook)
(add-hook 'c-mode-hook 'aqua/cpp-mode-hook)
#+end_src

** cc-mode
This is the major mode for =C= and similar languages. Here, we customise the
handling of these languages.

#+begin_src emacs-lisp :lexical no
(use-package cc-mode
  :ensure t

  :demand t

  :hook
  ((c++-mode-hook . (lambda ()
			          (setq comment-start "/**")
			          (setq comment-end "*/")
			          (setq flycheck-clang-language-standard "c++20"
				            flycheck-gcc-language-standard "c++20")))
   (c-mode-hook . (lambda ()
			        (setq flycheck-clang-language-standard "c17"
				          flycheck-gcc-language-standard "c17")))
   (c++-mode    . my/c++-mode-indent-init)
   (c-mode      . (lambda ()
                    (setq comment-start "// "
                          comment-end ""))))

  :bind
  ((:map c++-mode-map
	     ("C-c x c"   . cpp/compile-current-file)
	     ("C-c x e"   . cpp/run-exec-file)
	     ("C-c x o"   . cpp/compile-and-run))
   (:map c-mode-map
	     ("C-c x c"   . cpp/compile-current-file)
	     ("C-c x e"   . cpp/run-exec-file)
	     ("C-c x o"   . cpp/compile-and-run))
   (:map c-mode-base-map
	     ("C-c x r" . recompile)))

  :custom
  (c-basic-offset 4)

  :preface
    (progn
      (defun cpp/compile-current-file ()
        "Compiles a C/C++ file on the fly."
        (interactive)
        (let* ((clang-choices '(("c" . "clang -std=c17") ("cpp" . "clang++ -std=c++20")))
	           (filename (file-name-nondirectory buffer-file-name))
	           (file-ext (file-name-extension buffer-file-name))
	           (compile-choice (cdr (assoc file-ext clang-choices))))
          (compile (concat compile-choice " -Wall -pedantic " filename " -o " (file-name-sans-extension filename) ".o"))))

      (defun cpp/run-exec-file ()
        "Runs an executable file named after the buffer if it exists."
        (interactive)
        (if (file-executable-p (concat (file-name-sans-extension buffer-file-name) ".o"))
	        (async-shell-command
	         (concat "./" (file-name-nondirectory (file-name-sans-extension buffer-file-name)) ".o"))))

      (defun cpp/compile-and-run ()
        (interactive)
        "Compiles a C/C++ file then runs it."
        (cpp/compile-current-file)
        (cpp/run-exec-file))

      ;; Default C++ style
      (defun my/build-tab-stop-list (width)
        (let ((num-tab-stops (/ 80 width))
              (counter 1)
              (ls nil))
          (while (<= counter num-tab-stops)
            (setq ls (cons (* width counter) ls))
            (setq counter (1+ counter)))
          (set (make-local-variable 'tab-stop-list) (nreverse ls))))

      (defun my/c++-mode-indent-init ()
        (interactive)
        (google-set-c-style)
        (setq-default tab-width 4) ;; change this to taste, this is what K&R uses
        (make-local-variable 'c-basic-offset)
        (setq c-basic-offset tab-width)
        (make-local-variable 'c-indent-level)
        (setq c-indent-level tab-width)
        (setq indent-tabs-mode nil))

      ;; Default C-style
      (setq my/cc-style
            '("cc-mode"
              (c-offsets-alist .
                               ((func-decl-cont       . ++)
                                (member-init-intro    . +)
                                (inher-intro          . ++)
                                (comment-intro        . 0)
                                (arglist-close        . c-lineup-arglist)
                                (topmost-intro        . 0)
                                (block-open           . 0)
                                (inline-open          . 0)
                                (substatement-open    . 0)
                                (label                . /)
                                (case-label           . +)
                                (statement-case-open  . +)
                                (statement-case-intro . +)
                                (access-label         . /)
                                (innamespace          . -)
                                (label                . 0)
                                (case-label           . +)
                                (inextern-lang        . 0)
                                ))))

      ;; Make C/C++ indentation reliable
      (defun my/c-indent-offset-according-to-syntax-context (key val)
        ;; remove the old element
        (setq c-offsets-alist (delq (assoc key c-offsets-alist) c-offsets-alist))
        ;; new value
        (add-to-list 'c-offsets-alist '(key . val)))

      ;; Default C-style
      (defun my/c-mode-indent-init ()
        (interactive)
        (c-set-style "Linux")
        (c-set-offset 'substatement-open 0)
        (c-set-offset 'innamespace 0)
        (c-set-offset 'inextern-lang 0)
        (c-toggle-electric-state -1)

        (setq-default c-default-style "Linux")
        (c-add-style "Linux" my/cc-style)
        (my/tabs-setup t 8)

        (make-local-variable 'c-basic-offset)
        (setq c-basic-offset tab-width)
        (make-local-variable 'c-indent-level)
        (setq c-indent-level tab-width)

        (my/c-indent-offset-according-to-syntax-context 'substatement-open 0)

        ;; ensure fill-paragraph takes doxygen @ markers as start of new
        ;; paragraphs properly
        (setq-default comment-multi-line t
                      paragraph-start "^[ ]*\\(//+\\|\\**\\)[ ]*\\([ ]*$\\|@param\\)\\|^\f"))

      (defun my/c-files-hook ()
        (when (string= (file-name-extension buffer-file-name) "c")
          (my/c-mode-indent-init))

        (when (string= (file-name-extension buffer-file-name) "cpp")
          (my/c++-mode-indent-init))

        (when (string= (file-name-extension buffer-file-name) "h")
          (my/c++-mode-indent-init)))))
#+end_src

** Some LSP configuration
Set extra arguments for =clangd= if =LSP= is used.

#+begin_src emacs-lisp :lexical no
;; extra arguments for clangd and lsp
(with-no-warnings
  (defconst ccls-args nil)
  (defconst clangd-args '("-j=4"
                          "--background-index"
                          "--clang-tidy"
                          "--completion-style=bundled"
                          "--header-insertion=iwyu"
                          "--header-insertion-decorators=0"
                          "--enable-config"))
  (with-eval-after-load 'lsp-mode
    ;; We Prefer `clangd' over `ccls'
    (cond ((executable-find "clang")
           (setq lsp-clients-clangd-executable "clangd"
                 lsp-clients-clangd-args clangd-args))
          ((executable-find "ccls")
           (setq lsp-clients-clangd-executable "ccls"
                 lsp-clients-clangd-args ccls-args)))))
#+end_src

* ccls
=ccls= is a =cquery= based C/C++/Objective-C language server supporting cross
references, hierarchies, completion and semantic highlighting.

First install and build the =ccls= as shown below:

#+begin_src shell :tangle no
git clone --depth=1 --recursive https://github.com/MaskRay/ccls

brew info llvm
cmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH="$(brew --prefix llvm)/lib/cmake"
cmake --build Release

$ ./Release/ccls --version
Homebrew ccls version <unknown>
clang version 16.0.6
#+end_src

#+begin_src emacs-lisp
;; ccls - language server
(use-package ccls
  :disabled t
  :init
  (setq ccls-sem-highlight-method 'font-lock)
  :hook
  ((c-mode c++-mode objc-mode cuda-mode) . (lambda () (require 'ccls) (lsp-deferred)))
  :config
  ;; add ccls to path if you haven't done so
  (setq ccls-initialization-options '(:index (:comments 2)
                                             :completion (:detailedLabel t)
                                             :cacheDirectory "/tmp/ccls_cache")
        ccls-executable "~/.emacs.d/ccls/Release/ccls")

  ;; lsp customisations
  (lsp-register-client
   (make-lsp-client
    :new-connection (lsp-tramp-connection (cons ccls-executable ccls-args))
    :major-modes '(c-mode c++-mode cuda-mode objc-mode)
    :server-id 'ccls-remote
    :multi-root nil
    :remote? t
    :notification-handlers
    (lsp-ht ("$ccls/publishSkippedRanges" #'ccls--publish-skipped-ranges)
            ("$ccls/publishSemanticHighlight" #'ccls--publish-semantic-highlight))
    :initialization-options (lambda () ccls-initialization-options)
    :library-folders-fn nil))

  :custom (ccls-enable-skipped-ranges nil))
#+end_src

CCLS and Eglot configuration

#+begin_src emacs-lisp :lexical no
;; eglot ccls workspace configuration
(with-eval-after-load "eglot"
  (add-to-list 'eglot-workspace-configuration
               `((:ccls . ((:clang . ,(list
                                       :extraArgs
                                       ["-isystem/Library/Developer/CommandLineTools/usr/include/c++/v1"
                                        "-isystem/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include"
                                        "-isystem/usr/local/include"]
                                       :resourceDir
                                       (cdr (aqua/get-process "clang" "-print-resource-dir")))))))))
#+end_src

* Irony mode

[[https://github.com/Sarcasm/irony-mode][irony-mode]] is a =C/C++= minor mode for Emacs powered by ~libclang~.

** Basic setup

=irony-mode= is an Emacs minor-mode that aims at improving the editing
experience for the =C=, =C++= and =Objective-C= languages. It works by using
a combination of an Emacs package and a =C++= program (*irony-server*)
exposing =libclang=.

It provides the below features while editing a =C=, =C++= or an =ObjectiveC= file.

- Code completion
- Syntax Checking
- Documentation lookup in association with *eldoc*

*** Package installation in =Emacs=

The *Emacs* package can be installed from =MELPA= using any standard
package management procedures like =use-package= or custom =elisp= code.

- =M-x package-install RET irony RET=

*** The simplest configuration

The simplest configuration would be just including the below in
appropriate =elisp=

#+BEGIN_SRC elisp
(add-hook 'c++-mode-hook  'irony-mode)
(add-hook 'c-mode-hook    'irony-mode)
(add-hook 'objc-mode-hook 'irony-mode)
#+END_SRC

Install and build ~irony-mode~ first. To build, use the *LLVM* either from homebrew
or installed from llvm source.

** irony-server installation post the =elisp= package installation

Once *irony* package is installed on =Emacs= the *irony-server* needs to be
built using appropriate =libclang=. The following section shows the
build details.

*** Build instructions

On *OSX* it is advisable to use the =llvm= compiler which can be installed using
homebrew.

**** Create build directories

#+BEGIN_SRC shell :tangle no
$ cd ~/aquamacs.d/elpa/irony-20220110.849/
$ mkdir build
$ cd build
#+END_SRC

**** Now run the =cmake= from inside the build directory, using the below command(s)

#+begin_src shell :tangle no
$ cmake -DCMAKE_PREFIX_PATH=/opt/homebrew/opt/llvm \
> -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON \
> -DCMAKE_INSTALL_PREFIX=~/.emacs.d/irony/ \
> ~/.emacs.d/elpa/irony-20220110.849/server

-- The C compiler identification is AppleClang 13.0.0.13000029
-- The CXX compiler identification is AppleClang 13.0.0.13000029
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Performing Test HAVE_FFI_CALL
-- Performing Test HAVE_FFI_CALL - Success
-- Found FFI: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/usr/lib/libffi.tbd
-- Performing Test Terminfo_LINKABLE
-- Performing Test Terminfo_LINKABLE - Success
-- Found Terminfo: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/usr/lib/libcurses.tbd
-- Found ZLIB: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/usr/lib/libz.tbd (found version "1.2.11")
-- Found LibXml2: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/usr/lib/libxml2.tbd (found version "2.9.4")
-- Irony package version is '1.5.0'
-- Found emacs: /Applications/emacs.app/Contents/MacOS/Emacs
-- Configuring done
-- Generating done
-- Build files have been written to: /Users/sampathsingamsetty/aquamacs.d/elpa/irony-20220110.849
#+end_src

Once the build files are all successfully generated, run the below command to
create the irony-server inside the .emacs.d folder. This command should be run
from within the build directory as above.

#+begin_src shell :tangle no
λ cmake --build . --use-stderr --config Release --target install
[ 12%] Building CXX object src/CMakeFiles/irony-server.dir/support/CommandLineParser.cpp.o
[ 25%] Building CXX object src/CMakeFiles/irony-server.dir/support/TemporaryFile.cpp.o
[ 37%] Building CXX object src/CMakeFiles/irony-server.dir/Command.cpp.o
[ 50%] Building CXX object src/CMakeFiles/irony-server.dir/CompDBCache.cpp.o
[ 62%] Building CXX object src/CMakeFiles/irony-server.dir/Irony.cpp.o
[ 75%] Building CXX object src/CMakeFiles/irony-server.dir/TUManager.cpp.o
[ 87%] Building CXX object src/CMakeFiles/irony-server.dir/main.cpp.o
[100%] Linking CXX executable ../bin/irony-server
[100%] Built target irony-server
#+end_src

**** Check and configure

Checking the version of irony-server

#+begin_src shell :tangle no
λ ./irony-server -v
irony-server version 1.5.0
Homebrew clang version 14.0.6
#+end_src

For all completion candidates, take the output of below and add to
~irony-additional-clang-options~ or to ~.clang_complete~ file.

#+begin_src shell :tangle no
echo | clang -x c++ -v -E - 2>&1 | sed -n '/^#include </,/^End/s|^[^/]*\([^ ]*/include[^ ]*\).*$|-I\1|p'
#+end_src

#+begin_src emacs-lisp
(use-package irony
  :defer 5
  :quelpa (:fetcher github :repo "https://github.com/Sarcasm/irony-mode")
  :init
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  :config
  (setq irony-user-dir (expand-file-name "irony" user-emacs-directory))
  ;; replace the `completion-at-point' and `complete-symbol' bindings in
  ;; irony-mode's buffers by irony-mode's function
  ;; counsel-irony is available as a part of counsel package
  (defun my-irony-mode-hook ()
    (define-key irony-mode-map
      [remap completion-at-point] 'counsel-irony)
    (define-key irony-mode-map
      [remap complete-symbol] 'counsel-irony))
  (add-hook 'irony-mode-hook 'my-irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
  ;; (setq irony-extra-cmake-args (format
  ;;                               (concat "%s%s")
  ;;                               "-DCMAKE_PREFIX_PATH="
  ;;                               (aqua/string-trim-final-newline
  ;;                                (shell-command-to-string "brew --prefix llvm"))))
  (add-hook 'c++-mode-hook
            (lambda ()
              (setq irony-additional-clang-options
                    '("-std=c++20 -Wall"
                      "-I/usr/local/include/opencv4"
                      "-I/opt/homebrew/opt/llvm/bin/../include/c++/v1"
                      "-I/opt/homebrew/Cellar/llvm/18.1.6/lib/clang/18/include"
                      "-I/Library/Developer/CommandLineTools/SDKs/MacOSX14.sdk/usr/include"))))
  :custom
  (custom-set-variables
   '(irony-additional-clang-options
     '("-I/Library/Developer/CommandLineTools/usr/include/c++/v1"))))
#+end_src

** Company mode integration using company-irony
#+begin_src emacs-lisp :lexical no
;; company integration
(use-package company-irony
  :defer 3
  :after (company)
  :config
  (progn
    (eval-after-load 'company '(add-to-list 'company-backends 'company-irony))))
#+end_src

** Eldoc integration
#+begin_src emacs-lisp :lexical no
;; eldoc integration for irony
(use-package irony-eldoc
  :defer t
  :after (irony)
  :config
  (add-hook 'irony-mode-hook #'irony-eldoc))
#+end_src

** Flycheck integration
Using flycheck for buffer errors
#+begin_src emacs-lisp :lexical no
;; flycheck integration for irony
(use-package flycheck-irony
  :defer t
  :after (flycheck)
  :config
  (progn
    (eval-after-load 'flycheck '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))))
#+end_src

* Coding conventions

If [[https://google.github.io/styleguide/cppguide.html][google c++ conventions]] are followed, the [[https://github.com/google/styleguide/blob/gh-pages/google-c-style.el][google-c-style]] package changes
certain default values to ensure that the conventions are followed as much as
possible.

#+begin_src emacs-lisp :lexical no
(use-package google-c-style
  :defer t
  :hook
  (((c-mode c++-mode) . google-set-c-style)
   (c-mode-common . google-make-newline-indent)))
#+end_src

* Cmake

CMake is a cross-platform build system generator. For its support with GNU
Emacs, the [[https://github.com/Kitware/CMake/blob/master/Auxiliary/cmake-mode.el][cmake-mode]] package with the installation of the
[[https://emacs-lsp.github.io/lsp-mode/page/lsp-cmake/][cmake-language-server]] LSP server is sufficient. To use, it is required to
configure the LSP package and install the LSP server through LSP mode or with
the relevant system package manager.

#+begin_src emacs-lisp :lexical no
;; cmake support
(use-package cmake-mode
  :hook
  (cmake-mode . lsp-deferred)

  :mode
  (("CMakeLists\\.txt\\'" . cmake-mode)
   ("\\.cmake\\'"         . cmake-mode))

  :config
  (set-company-backends-for! cmake-mode company-cmake company-dabbrev-code company-dabbrev))
#+end_src

** Cmake font lock

For better managing the syntax colours especially with respect to function
arguments, it is visually useful to install [[https://github.com/Lindydancer/cmake-font-lock][cmake-font-lock]].

#+begin_src emacs-lisp :lexical no
;; cmake font lock
(use-package cmake-font-lock
  :defer t
  :hook
  (cmake-mode . cmake-font-lock-activate))
#+end_src

** Compiling with cmake-ide

For compiling with =CMake= in ~C++~, use [[https://github.com/atilaneves/cmake-ide/blob/master/cmake-ide.el][cmake-ide]] by indicating where the
~CMakeLists.txt~ file is present in the project.

#+begin_src emacs-lisp :tangle no
;; cmake-ide for compiling c++
(use-package cmake-ide
  :ensure no
  :init (cmake-ide-setup)
  :hook (c++-mode . aqua/cmake-ide-find-project)
  :preface
  (defun aqua/cmake-ide-find-project ()
    "Find the directory of the project for cmake-ide."
    (with-eval-after-load 'projectile
      (setq cmake-ide-project-dir (projectile-project-root))
      (setq cmake-ide-build-dir (concat cmake-ide-project-dir "build")))
    (setq cmake-ide-compile-command
          (concat "cd " cmake-ide-build-dir " && cmake .. && make"))
    (cmake-ide-load-db))

  (defun aqua/switch-to-compilation-window ()
    "Switch to the *compilation* buffer after compilation."
    (other-window 1))
  :bind ([remap comment-region] . cmake-ide-compile)
  :config (advice-add 'cmake-ide-compile :after #'aqua/switch-to-compilation-window))
#+end_src

* Code formatting
In a collaborative project, code formatting tools like /clang-format/, have been
widely used to make sure that the code written by multiple people or teams have
a uniform style and format. The section deals with setting of the
=clang-format= for formatting the =C/C++= code blocks.
** Format configuration file
In order to format our code, we need a configuration file ~.clang-format~. This
file could be generated from certain pre-configured styles.
To generate ~.clang-format~ from style ~llvm~ or ~google~, run the following command
in the terminal.

#+begin_src shell :lexical no :tangle no
# llvm style
clang-format -style=llvm -dump-config > .clang-format

# google style
clang-format -style=google -dump-config > .clang-format
#+end_src

Other styles available are llvm, chromium, mozilla, webkit, microsoft.

=clang-format= could format a single file or all files with the same file
extension. For example, to format *.cpp* extension, run the following command in
the terminal.

#+begin_src shell :lexical no :tangle no
# for formatting all cpp files
clang-format -i *.cpp

# for formatting all .h, .c, .hpp, .cpp, .cu files together
find . -regex '.*\.\(cpp\|hpp\|cu\|c\|h\)' -exec clang-format -style=file -i {} \;
#+end_src

*** COMMENT clang-format
Format =c/c++= code using the command line tool ~clang-format~
#+begin_src emacs-lisp :lexical no
(use-package clang-format
  :quelpa
  (clang-format :fetcher github :repo "sonatard/clang-format")

  :commands
  (clang-format
   clang-format-region
   clang-format-buffer)

  :config
  (setq clang-format-style-option "llvm"))
#+end_src

** clang-format-plus
[[https://github.com/SavchenkoValeriy/emacs-clang-format-plus][emacs-clang-format-plus]] is a small package aimed at improving the user
experience of using clang-format in Emacs. ~clang-format+~ defines a minor mode
~clang-format+-mode~, which applies ~clang-format~ on save. It can also apply
clang-format to the modified parts of the region only and try to be smart about
it.

#+begin_src emacs-lisp :lexical no :tangle no
;; clang format plus
(use-package clang-format+
  :disabled t
  :after (cc-mode)
  :quelpa (clang-format+
           :fetcher github
           :repo "SavchenkoValeriy/emacs-clang-format-plus")
  :commands (clang-format-buffer)
  :config
  (fset 'c-indent-region 'clang-format-region)
  (add-hook 'c-mode-common-hook #'clang-format+-mode)
  :init
  (defun clang-format-buffer-smart ()
    "Reformat buffer if .clang-format exists in the projectile root."
    (when (f-exists? (expand-file-name ".clang-format" (projectile-project-root)))
      (clang-format-buffer)))
  (defun clang-format-buffer-save-hook ()
    (when c-buffer-is-cc-mode
      (clang-format-buffer-smart)))
  (add-hook 'before-save-hook #'clang-format-buffer-save-hook))
#+end_src

* Font locking
This package aims to provide a simple highlight of the ~C++~ language without
dependency.

#+begin_src emacs-lisp :lexical no
;; font locking for cpp
(use-package modern-cpp-font-lock
  :after (cc-mode)
  :ensure t
  :quelpa
  (:fetcher github :repo "ludwigpacifici/modern-cpp-font-lock")
  ;;:diminish modern-c++-font-lock-mode
  :config
  (add-hook 'c++-mode-hook #'modern-c++-font-lock-mode))
#+end_src

* Code compilation helpers

A couple of functions to help compile standard =C/C++= programs.

#+begin_src emacs-lisp :lexical no
;; compiling c and cpp files
(defun compile-with-g++()
  (interactive)
  (unless (file-exists-p "Makefile")
    (set (make-local-variable 'compile-command)
     (let ((file (file-name-nondirectory buffer-file-name)))
       (format "%s -Wall -W -Werror -std=c++20 -o %s %s"
           (if  (equal (file-name-extension file) "cpp") "g++" "gcc" )
           (file-name-sans-extension file)
           file)))
    (compile compile-command)))

(defun compile-with-clang++()
  (interactive)
  (unless (file-exists-p "Makefile")
    (set (make-local-variable 'compile-command)
     (let ((file (file-name-nondirectory buffer-file-name)))
       (format "%s -Wall -W -Werror -std=c++20 -o %s %s"
           (if  (equal (file-name-extension file) "cpp") "clang++" "clang" )
           (file-name-sans-extension file)
           file)))
    (compile compile-command)))
#+end_src

* Sample stubs

A sample =Makefile= to compile a =c++= program using either =g++= or =clang++= is as
under:

#+begin_src shell :eval no
# sample C++ program name: sample.cpp
# run Makefile as under
$ make
clang++ -Wall -W -Werror -O2 -std=c++20 -o sample sample.cpp

# clean the build
$ make clean
rm -vrf sample
sample

# default compiler in Makefile is clang++ but we can supply another
# one in the command line flag as under
$ make CXX=g++
g++ -Wall -W -Werror -O2 -std=c++20 -o sample sample.cpp
#+end_src

The relevant =Makefile= is as under:

#+begin_src shell :eval no
# compiler options and output files
CXX = clang++
CFLAGS = -Wall -W -Werror -O2 -std=c++20
OUTPUTFILE = sample

# default target
.PHONY: all
	all: $(OUTPUTFILE)

# build sample from sample.cpp
# using a different compiler: make CXX=g++
# $@ expands to sample and the $< expands to sample.cpp
$(OUTPUTFILE): sample.cpp
	$(CXX) $(CFLAGS) -o $@ $<

# delete sample
.PHONY: clean
clean:
	rm -vrf sample
#+end_src

** Special Macros to be used in Makefiles
Now all those =$@= variables that appear in the =Makefile= shown and elsewhere in
the makefile are clearly not plain old macros, since they're never defined and
yet the makefile works quite well. The reason is that there are a number of
special macros with one character names that are only useable as part of a
dependency rule:

  + $@ The file name of the target.

  + $< The name of the first dependency.

  + $* The part of a filename which matched a suffix rule.

  + $? The names of all the dependencies newer than the target separated by spaces.

  + $^ The names of all the dependencies separated by spaces, but with duplicate names removed.

  + $+ The names of all the dependencies separated by spaces with duplicate names included and in the same order as in the rule.
